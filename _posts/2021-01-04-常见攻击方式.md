---
title: '常见攻击方式'
date: 2021-01-04
permalink: /posts/2021/01/blog-post-1/
tags:
  - Security
  - Hacker
  - Ontology
---

目录：

- 网络安全
  - SQL注入
  - XSS攻击
  - CSRF攻击
  - DDoS攻击
  - DNS劫持
  - TCP劫持
  - 端口扫描技术
- 系统安全
  - 栈溢出攻击
  - 整数溢出攻击
  - 空指针攻击
  - 释放后使用攻击
  - HOOK
  - 权限提升
  - 可信计算
- 密码学
  - 对称加密 & 非对称加密
  - 秘钥交换技术
  - 信息摘要算法
  - 数据编码技术
  - 多因子认证技术

信息安全大体可分为三个大的分支：

网络安全
 - SQL注入

SQL注入攻击的核心在于让Web服务器执行攻击者期望的SQL语句，以便得到数据库中的感兴趣的数据或对数据库进行读取、修改、删除、插入等操作。

而如何让Web服务器执行攻击者的SQL语句呢？SQL注入将SQL语句放置于Form表单或请求参数之中提交到后端服务器，后端服务器如果未做输入安全校验，直接将变量取出进行数据库查询，则极易中招。

举例：

对于一个根据用户ID获取用户信息的接口，后端的SQL语句一般是这样：

select name,[...] from t_user where id=$id

其中，$id就是前端提交的用户id，而如果前端的请求是这样：

GET xx/userinfo?id=1%20or%201=1

其中请求参数id转义后就是1 or 1=1，如果后端不做安全过滤直接提交数据库查询，SQL语句就变成了：

select name,[...] from t_user where id=1 or 1=1 (其结果会获取用户表中的所有数据)

[防御手段]：对输入进行检测，阻断带有SQL语句特征对输入



XSS攻击

全称跨站脚本攻击（Cross Site Scripting），为了与重叠样式表CSS区分，换了另一个缩写XSS。

XSS攻击的核心是将可执行的前端脚本代码（一般为JavaScript）植入到网页中，让victim的浏览器执行攻击者写的JS代码。XSS攻击一般可分为两种：

反射型

1、攻击者将JS代码作为请求参数放置URL中，诱导用户点击
例：
http://localhost:8080/test?name=<script>alert("you are under attack!")</script>

2、用户点击后，该JS作为请求参数传给Web服务器后端

3、后端服务器没有检查过滤，简单处理后放入网页正文中返回给浏览器

4、浏览器解析返回的网页，中招！

存储型

攻击脚本直接经服务器转手后返回浏览器触发执行，区别在于能够将攻击脚本入库存储，在后面进行查询时，再将攻击脚本渲染进网页，返回给浏览器触发执行。常见的套路举例如下：

1、攻击者网页回帖，帖子中包含JS脚本

2、回帖提交服务器后，存储至数据库

3、其他网友查看帖子，后台查询该帖子的回帖内容，构建完整网页，返回浏览器

4、该网友浏览器渲染返回的网页，中招！

[防御手段]：前后端均需做好内容检测，过滤掉可执行脚本


CSRF攻击

在打开A网站的情况下，另开Tab页面打开恶意网站B，此时在B页面的“唆使”下，浏览器发起一个对网站A的HTTP请求。这个过程的危害在于2点：

1、这个HTTP请求不是用户主动意图，而是B“唆使的”一个危害较大的请求操作(修改密码，删除数据等)。

2、因为之前A网站已经打开了，浏览器存有A下发的Cookie或其他用于身份认证的信息，这一次被“唆使”的请求，将会自动带上这些信息，A网站后端无法分清该请求是否为用户的真实意图



DDoS攻击

分布式拒绝服务攻击让服务不可用。常用于攻击对外提供服务的服务器，诸如Web服务，邮件服务，DNS服务，即时通讯服务等。
现在的服务器早已不是一台服务器那么简单，一个可访问的域名背后是数不清的CDN节点及数不清的Web服务器。
根据具体实施手段的不同，又可以进一步细分：SYN Flood, ICMP Flood, UDP Flood等。
[防御手段]：流量清洗、SYN Cookie等等。




DNS劫持
DNS提供服务用来将域名转换成IP地址，然而在早期协议的设计中并没有太多考虑其安全性，对于查询方来说：
    我去请求的真的是一个DNS服务器吗？是不是别人冒充的？
    查询的结果有没有被人篡改过？这个IP真是这个网站的吗？
DNS协议中没有机制去保证能回答这些问题，因此DNS劫持现象非常泛滥，为了在客户端对收到对DNS应答进行校验，出现了DNSSEC技术，一定程度上可以解决上面的部分问题。httpDNS服务可一招釜底抽薪，



TCP劫持
TCP层是TCP/IP协议族中位于传输层。协议本身并没有对TCP传输的数据包进行身份验证，所以只要知道一个TCP连接中的seq和ack后就可以很容易的伪造传输包，假装任意一方与另一方进行通信，这一过程被称为TCP会话劫持（TCP Session Hijacking）。



端口扫描技术
作为网络攻击的前期阶段，用于探测目标开启了哪些服务，以便接下来发起针对该服务的攻击。
端口扫描的一般可分为：
对于基于UDP的服务，发送对应服务都请求包，查看是否有应答；
对于基于TCP的服务，尝试发起三次握手发送TCP SYN数据包，查看是否有应答。
如果远端服务器进行了响应，则表明对端服务器上运行了对应的服务，接下来则是进一步探知对端服务器使用的操作系统、运行的服务器程序类型、版本等等，随即针对对应的漏洞程序发起网络攻击。
[防御手段]：使用防火墙等安全产品，即时发现和阻断非法的扫描探测行为。


系统安全
系统安全版块中的技术，一般是指攻击发生在终端之上，与操作系统息息相关。

栈溢出攻击
现代计算机基本上都是建立在冯－诺伊曼体系之上，该体系有一个最大的缺陷就是数据和指令都保存在存储器中，即在计算机的内存中，既包含了程序运行的所有代码指令，又包含了程序运行的输入输出等各种数据，并没有一种强制的机制将指令和数据区分。不管是x86／x64处理器，还是ARM处理器，均采用了“寄存器＋堆栈式”的设计，而这个堆栈中，既包含了程序运行各个函数栈帧中的变量数据等信息，还保存了函数调用产生的返回地址。所谓栈溢出攻击，就是通过一些手段输入到栈中的缓冲区中，冲破缓冲区原有的界限，将存储返回地址的位置覆盖为一个数值，使其指向攻击者提前布置的恶意代码位置，劫持了程序的执行流程。

[防御手段]：现代操作系统针对栈溢出攻击已经有非常成熟的应对方案，像Linux平台的Stack Canary，Windows平台的GS机制等等。



整数溢出攻击
整数溢出攻击的目标不是栈中的缓冲区，而是一个整数。
我们知道，计算机数值以补码的方式表示和存储。在表示一个有符号数时，最高位是用来表示这是一个正数（0）还是一个负数（1），比如对于一个16位的short变量而言，+1是(0000 0000 0000 0001)而-1是(1111 1111 1111 1111)。对一个short变量值32767(0111 1111 1111 1111)执行＋1操作，将变成-32768的补码形式(1000 0000 0000 0000), 如果这个变量作为strcpy的参数length，或是作为数组的下标index，整数溢出将导致可怕的后果，轻则进程崩溃，服务宕机，重则远程代码执行，拿下控制权。



空指针攻击
空指针一般出现在指针没有初始化或使用new进行对象创建/内存分配失败，且程序员并没有检查指针是否为空而进行访问导致的攻击。
多数情况下，空指针会导致内存地址访问异常，程序崩溃退出，造成拒绝服务的现象，而在一些特殊的情况下，部分操作系统允许分配内存起始地址为0的内存页面，若攻击者提前在该页面准备好攻击代码，则可能出现执行恶意代码的风险。


释放后使用攻击
释放后使用Use After Free意为访问一个已经释放后的内存块。较多的出现在针对浏览器的JavaScript引擎的攻击中。
正常情况下，一个释放后的对象我们是没法再访问的，但如果程序员粗心大意，在delete对象后，没有即时对指针设置为NULL，在后续又继续使用该指针访问对象（比如通过对象的虚函数表指针调用虚函数），将出现内存访问异常。若攻击者在delete对象后，马上又new一个同样内存大小的对象，在现代操作系统的堆内存管理算法中，会有很大概率将这个新的对象放置于刚刚被delete的对象的位置处。这个时候还通过原来对象的指针去访问，将出现鸠占鹊巢，出现可怕的后果。

[防御手段]：养成好的编程习惯，对象delete后，将指针及时置空。




HOOK
HOOK原意钩子的意思，在计算机编程中时常用到，用来改变原有程序执行流程。
除了消息HOOK，用得更多的是程序执行流程层面的HOOK。恶意代码被注入目标程序后，在函数入口处添加跳转指令，导致执行到此处的线程转而执行攻击者的代码，实现修改参数、过滤参数的目的。
HOOK技术不仅为黑客使用，安全软件用的更多，因其需要守护整个系统的安全防线，需通过HOOK技术在各处敏感API处设立检查，从而抵御非法调用攻击行为。另外，软件补丁技术中也时常用到HOOK技术，软件厂商通过HOOK，修改既有程序的执行逻辑，从而达到修复漏洞的目的。



权限提升
现代操作系统都对运行于其中的进程、线程提供了权限管理，即便程序因为漏洞原因被攻击执行了恶意代码，但因为操作系统的权限控制，恶意代码能干的事情也有限。
因程序执行的时候，所属进程／线程拥有一个安全令牌，用以标识其安全等级，在访问资源和执行动作的时候由操作系统Kernel审核。权限提升的目标就是将这个安全令牌更改为高等级的令牌，使其在后续访问敏感资源和执行敏感动作时，凭借该令牌可以通过系统的安全审核。更改安全令牌的惯用方法便是利用操作系统内核漏洞（如前面所述的栈溢出、整数溢出、释放后使用等）执行攻击者的代码，从而实现对安全令牌的篡改。



可信计算
可信计算（Trusted Computing，TC）是一项由可信计算组（可信计算集群，前称为TCPA）推动和开发的技术。可信计算是在计算和通信系统中广泛使用基于硬件安全模块支持下的可信计算平台，以提高系统整体的安全性 [1] 。签注密钥是一个2048位的RSA公共和私有密钥对，它在芯片出厂时随机生成并且不能改变。这个私有密钥永远在芯片里，而公共密钥用来认证及加密发送到该芯片的敏感数据。
可信计算中一个非常重要的概念是可信执行环境TEE（Trusted Execution Environment)，简单来说就是在现有的计算机内部的世界里，再构建一个秘密基地，专门用于运行极度机密的程序。该秘密基地甚至连操作系统都轻易无法访问，更别说操作系统之上的应用程序了。在移动端，ARM芯片提供了名为TrustZone技术的技术，在硬件层面新增一个可信计算环境，包含一个可信OS，和一些可信APP，和普通环境在硬件层面隔离，处理器内部进行通信完成两个世界的交互。


密码学
由于数据传输的过程中会遇到信息泄漏、篡改、伪造的风险，加密技术应运而生。


对称加密 & 非对称加密
有加密就有解密，根据加密过程使用的密钥和解密过程使用的密钥是否相同，将加密算法分为了两个大类：对称加密和非对称加密。

最早出现的加密技术是对称加密
    对称加密：加密密钥和解密密钥一致，特点是加密速度快、加密效率高。常用的对称加密算法有：DES, AES,  RC4
对称加密方式中有一个非常关键的问题是，解密方需要拿到密钥才能进行解密，而若密钥通过网络传输则又会面临到安全风险。为解决密钥安全分发的问题，非对称加密应运而生！

   非对称加密：加密密钥与解密密钥不一致，特点是算法较复杂，但安全性高。非对称加密的密钥一般分为公钥和私钥，公钥公开，私钥需保密。常用于数字认证，如HTTPS中握手阶段的服务器认证。常用的非对称加密算法有：RSA，DH，ECC（椭圆曲线加密）

密钥交换技术
在互联网通信中，有加密就有解密，解密自然就需要密钥，那如何把这个密钥告诉对方呢？密钥交换算法就是要解决这个问题：如何安全的将密钥传输给对方？非对称加密可以解决这个问题：
    服务器负责生成一对公私钥，公钥告知客户端，私钥自己保存
    客户端拿到服务器端生产的公钥后，使用它来对后续通信将要使用的对称加密算法密钥进行加密传输
    服务端收到后使用之前生成的非对称加密的私钥进行解密操作，取得客户端发送过来的以非对称加密算法中生成的对应公钥加密后的对称加密算法的密钥
    此后双方即可通过对称加密进行传输通信

现时应用当中，Diffie-Hellma及其变种的密钥交换算法使用的更为广泛。Diffie-Hellman算法的核心是完全依靠数学运算实现密钥的交换。

信息摘要算法
信息摘要算法的目的之一是校验数据的正确性，算法公开，数据通过该算法得出一个摘要值，收到数据后通过该算法计算出这个摘要，前后对比就知道是否有被篡改。常用的信息摘要算法有：MD5, SHA1, SHA256



数据编码技术
数据编码技术目的是为了将数据编码以便传输。最常见的编码算法就是base64了，多用于编码二进制的数据，将不可见的字符编码后转换成64个常见字符组成的文本，便于打印、展示、传输、存储。如邮件eml格式中，将附件文件通过base64编码。除了base64，还有常用于比特币钱包地址编码的base58。base家族还有base85、base92、base128等众多算法。它们的区别不仅仅在于参与编码的字符集不同，算法执行也不一样。


多因子认证技术
多因子认证技术意为在传统密码认证之外，引入其他认证技术进行补充，使用2种及以上的方式共同完成认证。随着人工智能技术的发展，基于生物特征的认证技术突飞猛进：指纹认证，虹膜认证，人脸识别等。目前主流的多因子认证平台有三大派系：FIDO(国际标准)，IFAA(阿里系)，TUSI(腾讯系)
